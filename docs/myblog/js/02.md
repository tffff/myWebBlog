---
nav:
  title: JS闭包
  date: 2020-10-28 11:00
---

# JS 闭包

闭包的定义其实很简单：函数 A 内部有一个函数 B，函数 B 可以访问到函数 A 中的变量，那么函数 B 就是`闭包`。

很多人对于闭包的解释可能是函数嵌套了函数，然后返回一个函数。其实这个解释是不完整的，就比如我上面这个例子就可以反驳这个观点。

在 JS 中，闭包存在的意义就是让我们可以间接访问函数内部的变量。

**经典面试题，循环中使用闭包解决 `var` 定义函数的问题**

```js
for (var i = 1; i <= 5; i++) {
  setTimeout(function timer() {
    console.log(i);
  }, i * 1000);
}
//执行结果是5个6

//让执行结果变成1 2 3 4 5的方法有
//方法一 使用let块级作用域
for (let i = 1; i <= 5; i++) {
  setTimeout(function timer() {
    console.log(i);
  }, i * 1000);
}
//方法二 用闭包
for (let i = 1; i <= 5; i++) {
  (function(j) {
    setTimeout(function timer() {
      console.log(j);
    }, j * 1000);
  })(i);
}
```

## 闭包源头

闭包的产生由于**变量作用域链**引起的(由词法作用域导致)

**从 javascript 作用域说闭包**

在 ES5 及之前的语言规范中作用域分 3 种:

- 全局作用域
- 局部(函数作用域)
- eval 作用域。 [注意:没有块级作用域]

在函数中定义的变量，就属于局部作用域，且只对函数范围内其他表达式可见。 而函数内部又可以使用父函数中的变量这就是由于作用域链，当 JavaScript 查找与变量关联的值时，会遵循一个查找链。这个链是基于作用域的层次结构。 如下代码：

```js
var a = 'global variable';
(function() {
  console.log(a);
  var fn = function() {
    var a = 'local variable';
    console.log(a);
  };
  fn();
})();
//输出：global variable   local variable
```

首先是在全局作用域下面定义了一个全局变量`a`,然后调用了立即执行函数，所以第一个`console.log(a)`根据作用域查找，因为立即执行函数里面没有声明`a`就往上查找，就查找到`window`下面的`a`打印出`global variable`，接着这个立即执行函数声明了一个函数`fn`并且调用了它，所以第二个`console.log(a)`根据函数内部作用域查找就查找到了`local variable`

- 这里其实有 2 个闭包环境一个是`window`对象和立即执行函数所创建的闭包;另一个是立即执行函数和其内部声明的函数变量`fn`创建的闭包。
- 闭包其实就是个称呼，重要的是在这种场景下内部函数可以调用外部函数的变量，而这正是因为词法作用域链。
- 当闭包产生，在局部函数未被释放之前，被引用外部函数的变量就无法被释放

**那么我们刚刚说的“词法“作用域又是什么**。 其实词法就是指代环境:**由于函数决定作用域**，并且函数是一等公民可以直接用来参数传递等。那么作用域链是怎样来确定的呢: 下面的话背熟了: **作用域链是根据函数定义时候的位置确定的而不是在调用时**。--这就是“词法”作用域

词法作用域的理解可以看下面的例子：

```js
var count = 1;
function a() {
  console.log(count);
}

function b() {
  var count = 2;
  a();
}
b(); //打印出1

//要想打印出2 就可以使用闭包
var count = 1;

function b() {
  var count = 2;
  function a() {
    console.log(count);
  }
  a();
}
b();
```

为什么不是 2 呢？就是因为函数在定义的时候，里面的 a 已经存在了
