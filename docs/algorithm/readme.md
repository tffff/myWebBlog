# 数据结构和算法

### 数据结构

数据结构起源于程序设计，是用计算机来存储、组织数据的方式。数据结 构不是使我们学会编码，而是为我们提供一种编程的思想，具有更好的思路

- 广义的说法:**数据结构 = 数据存储 + 算法**
- 狭义的说法:**数据结构 = 数据的存储**

数据结构与算法是相互依托的关系。计算机解决问题，应该是先从具体问 题中抽象出一个适当的数据模型，设计出一个解此数据模型的算法:

- 数据结构 ==> 建筑工程中的建筑设计图
- 算法 ==> 工程中的施工流程图

**数据基本概念**

![数据](/datasrouce/数据.png)

数据元素是**基本单位** (比如列表的某一条)

数据项是**最小单位**(比如：name,age 等字段)

数据对象可以被实例化，数据对象和数据对象之间可以产生关联

**数据结构分类**

- **按逻辑结构分类** 反映数据元素之间的的逻辑关系

  - 集合（无逻辑关系）

    数据结构中的集合关系就类似于数学中的集合，集合中的数据成员是无序的，每个数据成员在集合中不能重复，仅且只出现一次

  - 线性结构（线性表）包括：**一维数组、队列、栈、串**

    线性结构中的数据元素之间是一对一的关系。也就是数据元素一个接一个 地排列。

  - 非线性结构 包括：**树、图、多维数组**

- **按存储结构分类** 数据结构在计算机内存中的表示

  - 顺序存储结构

    一个挨着一个排列，并且类型一致

  - 链式存储结构

    指针指向下一个数据在内存中的位置

  - 索引存储结构

    比如：map(es6)

  - 散列存储结构

### 内存与存储结构

1. 内存的原理与构造

内存本质上就是一个大数组，内存的下标就是地址，一个存储单位是一个字节(最小单位)，一个字节是 8 个比特位

地址：一个字节有一个编号，这个编号就是地址

指针：保存地址的变量

引用：是对指针的封装(引用)，

## 算法

### 什么是算法？

算法是完成某个特定任务的过程。通常数据结构作为工具来辅助之行算法。所以有了一个 流传甚广的公式:**程序 = 数据结构+算法**。

- 算法不是数学，但是可以用数学来描述

- 我们要做一件事情，这个过程本身就是算法
- 我们最常用的增删改查是算法的一部分
- 算法可以用自然语言、流程图、伪代码和计算机语言等手段来表示
- 在面向对象语言中，算法通常通过类的方法实现

### 算法的特征

- **有穷性**：算法必须能在执行有限个步骤之后终止

- **确切性**：每一步骤必须有确切的定义
- **输入项**：有 0 个或多个输入，用来规定初始情况，所谓 0 个输入是指算法本身定出了 初始条件
- **输出项**：有一个或多个输出，是对输入数据处理后的结果。没有输出的算法毫无意义
- **可行性**：算法中执行的任何计算步骤都是可以被分解为基本的可执行的操作步，每个 计算步都可以在有限时间内完成(也称之为有效性)。

### 怎样衡量算法的好坏？

- 算法的好坏主要通过算法复杂度来衡量
  - 时间复杂度
  - 空间复杂度
- 正确性
- 可读性
- 健壮性

### 计算算法复杂度

随着问题规模 n 的不断增大，时间复杂度不断增大，算法的执行效率越 低。

![时间复杂度](/datasrouce/时间复杂度.jpg)

一般做算法复杂度分析的时候，遵循下面的技巧:

- 有几重循环，一般来说一重就是 O(n)，两重就是 O(n^2)，以此类推
- 如果有二分，则为 O(logN)
- 保留最高项，去除常数项

**下面是计算复杂度的例子**

```js
let i = 0; //执行一次
while (i < n) {
  //执行n次
  console.log(`current i is${i}`); //执行n次
  i++; //执行n次
}
```

由此上面代码的复杂度为：1+n+n+n=1+3n，去掉常数项，所以复杂度是`O(n)`

```js
let number = 1; //执行一次
while (number < n) {
  //执行logN次
  number *= 2; //执行logN次
}
```

上述代码 while 跳出判断的条件是`number<n`,循环体内的增长速度是`2^n`,所以循环体内执行的实际操作次数是 logN,所以复杂度为`1+2*logN`,去掉常数项复杂度为`logN`

```js
for (let i = 0; i < n; i++) {
  //语句执行n次
  for (let j = 0; j < n; j++) {
    //语句执行n^2
    console.log('I am here'); //语句执行n^2
  }
}
```

上述代码的复杂度是`O(n^2)`

### 必须要掌握的算法

- 枚举

  - 核心思想:枚举所有的可能。

  - 本质:就是从所有候选答案中去搜索正确的解,使用该算法需要满足两个条件
    - (1)可预先确定候选答案的数量;
    - (2)候选答案的范围在求解之前必须有一个确定的集合。
  - 特点:
    - 枚举算法简单粗暴，暴力的枚举所有可能，尽可能地尝试所有的方法。
    - 速度可能很慢，却是我们最应该优先考虑的。
    - 实现最简单，并且得到的结果总是正确的。

- 递归
  - 核心思想:通过重复将问题分解为同类的子问题而解决问题的方法。
  - 特点:
    - 函数可以通过调用自身来进行递归
    - 递归可以完全取代循环
  - 递归由下面两部分组成:
    - (1)递归主体，就是要循环解决问题的代码
    - (2)递归的跳出条件，递归不能一直递归下去，需要完成一定条件后跳出
- 基本排序

  | 排序法     | 最佳时间复杂度 | 平均时间复杂度 | 最差时间复杂度 | 空间复杂度 | 稳定性 |
  | ---------- | -------------- | -------------- | -------------- | ---------- | ------ |
  | 冒泡排序   | n              | n^2            | n^2            | 1          | yes    |
  | 插入排序   | n              | n^2            | n^2            | 1          | yes    |
  | 选择排序   | n^2            | n^2            | n^2            | 1          | no     |
  | 二叉树排序 | nlogN          | nlogN          | nlogN          | 1          | yes    |
  | 快速排序   | nlogN          | nlogN          | n^2            | logN~n     | no     |
  | 堆排序     | nlogN          | nlogN          | nlogN          | 1          | no     |
  | 希尔排序   | nlogN          | nlogN          | n^2            | 1          | no     |

- 基本查找
  | 查找算法 | 平均时间复杂度 | 查找条件 |
  | ---- | ---- | ---- |
  | 顺序查找 | n | 无序或有序队列 |
  | 二分查找 | nlogN | 有序数组 |
  | 二叉排序树查找 | nlogN | 二叉排序树 |
  | 哈希表法（散列表） | 1 | 先创建哈希表 |
  | 分块查找 | nlogN | 无序或有序队列 |

  ### 怎样养成算法思维

  1. 化繁为简

     很难在第一时间内得到正确的思路的，这时候可以尝试一种由简至繁的思路。首先把问题规模缩小到非常容易解答 的地步。用来解决动态规划问题

  2. 分而治之

     - 把问题分为两半，变成两个与原来问题同构的问题

     - 当尝试这种思路时，其实只需要考虑两个问题:
     - 1.一分为二以后，问题是否被简化了?
     - 2.根据一分为二的两个问题的解，能否方便地得出整个问题的解?

  3. 化虚为实

     使用另外一种形式进行替换

## 前端中的数据结构和算法

- 程序=数据结构+算法

- 一个类就在设计数据结构，一个接口就在写一个自己设计的算法或者应用经典的算法
- 遇到在一个大的有序列表查找某一个记录可以用二分法之类的算法来提升查找的效率
- 要写出优雅、结构良好的程序，的确需要一定的算法功底
- 程序有很多 for 的时候就可以考虑算法，程序数据杂乱无章有必要设计数据结构了

## 算法面试刷题指南

- 算法中的计算机原理（位运算）
- 双指针技巧 （重要）
  - 快慢指针
  - 左右指针（二分指针）
- 递归思想
- 广度优先与深度优先（树结构）
- 最常见的算法范式
  - 暴力法
  - 分治法 （重要）
  - 回溯算法（重要）
  - 动态规划（重要）
  - 贪心算法
  - 分支界限法

**根据标签分类来刷题**

- 1. 数组、字符串、链表(高频优先刷，30-50 道)
- 2. 排序、查找(5-6 道，二分查找刷 10+)
- 3. 树、二叉树(性价比高，20-30 道)
- 4. 递归(都刷一遍)
- 5. 哈希表(怎么实现，解决冲突) 里面基本上都是应用题
- 6. 双指针 (出现的频率极高，多刷，每个档次都刷刷)
- 7. 堆 (精选 3-5)
- 8. 字典树 （难度较高）
- 9. 动态规划 (难度较高，大厂问的多，放在后期刷 20+)
- 10. 栈和队列 （应用层 10）
- 11. 位运算 （考察基本功）

1-6 ,10 精刷(没刷过的) 9 精刷两三道最少 78 粗刷

## 刷题要求

1. 不看题解
2. 先实现然后优化
3. 算出复杂度 找出最优解 去实现

## 刷题步骤

- 审题 抓取关键字
- 困难题粗刷
