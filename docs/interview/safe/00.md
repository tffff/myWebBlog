<!--
 * @Author: tf
 * @Date: 2021-04-07 16:33:49
 * @LastEditTime: 2021-04-07 17:45:26
 * @Description: 这是一段描述
-->

## 前端安全

### 1. XSS 跨站脚本攻击

就是攻击者想尽一切办法将可以执行的代码注入到网页中

- `存储型(server端)`
  - 场景：见于待用户保存数据的网站功能，如：论坛发帖、商品评论、私信等
  - 攻击步骤：
    - 攻击者将恶意代码提交到目标网站的数据库中
    - 用户将目标网站打开，从服务取出里面的恶意代码拼接成 HTML 返回到页面
    - 用户浏览器在收到响应之后解析执行，混在其中的恶意代码也被执行
    - 恶意代码窃取用户数据，并发送到攻击者指定的网站，或者冒充用户行为调用目标网站的服务，进行恶意操作
- `放射型(server端)`
  与存储型的区别是，放射型的攻击代码是在 URL 上，存储型的是在存在数据库中
  - 场景：通过 url 传递的参数攻击，如搜索、跳转等
  - 攻击步骤：
    - 攻击者包含恶意的代码在 url 上
    - 用户打开带有恶意代码的链接，网站服务将恶意代码取出，拼在 html 上面返回给浏览器
    - 用户浏览器接收到之后解析，混在里面的恶意代码也被执行
    - 恶意代码窃取用户数据，并发送到攻击者指定的网站，或者冒充用户行为调用目标网站的服务，进行恶意操作
- `DOM型(浏览器端)`
  Dom 型 xss 攻击中，取出恶意代码由浏览器完成，属于前端 javascript 自身的安全漏洞
  - 场景：通过 url 传递的参数攻击，如搜索、跳转等
  - 攻击步骤：

    - 攻击者包含恶意的代码在 url 上
    - 用户打开带有恶意代码的 url
    - 用户浏览器接收到之后解析，前端 javascript 取出代码执行，混在里面的恶意代码也被执行
    - 恶意代码窃取用户数据，并发送到攻击者指定的网站，或者冒充用户行为调用目标网站的服务，进行恶意操作

**预防方案**

- 对数据进行严格的编码，如 html 编码、js 编码、css 编码、url 编码，避免拼接 html;vue/react 技术栈避免使用 v-html/dangerouslySetInnerHTML
- CSP HTTP Header，即 Content-Security-Policy、X-XSS-Protection
  - 增加攻击难度，配置 CSP(本质是建立白名单，由浏览器拦截)
  - Content-Security-Policy: default-src 'self' -所有内容均来自站点的同一个源（不包括其子域名）
  - Content-Security-Policy: default-src 'self' \*.trusted.com-允许内容来自信任的域名及其子域名 (域名不必须与 CSP 设置所在的域名相同)
  - Content-Security-Policy: default-src https://baidu.com-该服务器仅允许通过HTTPS方式并仅从baicu.com域名来访问文档
- 输入验证：比如一些常见的数字、邮箱、url、电话号码进行判断
- 开启浏览器 XSS 防御，http only cookie，禁止 javascript 读取某些敏感 cookie，攻击者完成 XSS 注入后也无法窃取此 cookie
- 验证码

### 2. CSRF: 跨站请求伪造

攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求，利用受害者在被攻击网站所取得的注册凭证绕过后台的验证，达到冒充用户到被攻击者的网站执行想的权利

- 攻击举例：
  - 受害者登录一个网站 a 并保留了登录凭证(cookie)
  - 攻击者引诱受害者访问另一个网站 b
  - 网站 b 向 a 发送了一个请求 a.com/act=xxx 浏览器会默认携带 a.com 的 cookie
  - 网站 a 接收到请求后，对请求进行认证，确认是用户的凭证，误以为是用户自己发送的请求
  - 网站 a 以用户的名义执行了 act=xxx
  - 攻击完成，攻击者在用户不知道的情况下，冒充了受害则，让网站 a 执行了自己定义的操作
- 攻击类型：
  - `get类型`：比如某个 img 发送了一个请求
  - `post类型`：通过自动提交表单到恶意网站
  - `链接型`：诱导用户点击恶意链接
- 预防方案：
  因为 CSRF 通常是通过第三方网站来发起攻击，所以只能提高自己网站的安全才能防备

  - 同源检测：通过 header 中的 origin header、referer header 确定，在不同浏览器会有不同的实现，不能完全保证
  - CSRF token 验证：将 CSRF token 输出到页面中（通常保存在 session 中），页面提交的请求带上这个 token,服务器验证 token 是否正确
  - 双重 cookie 验证：在用户访问页面的时候带一个 cookie(随机字符串)，前端像后端发起请求时携带这个 cookie,并且添加到 url 上，服务器验证 cookie 的字段是否是和 url 上面是一样的，不一致就拒绝

    **优点**

    无需使用 session,适用面更广，易于实施；token 存在客户端中，不会给服务器压力；相对于 token 实施成本更低，可以前后端统一校验拦截，不需要一个一个接口加

    **缺点**
    cookie 中增加了额外的字段。 -如果有其他漏洞（例如 XSS），攻击者可以注入 cookie，那么该防御方式失效。 -难以做到子域名的隔离。 -为了确保 cookie 传输安全，采用这种防御方式的最好确保用整站 HTTPS 的方式，如果还没切 HTTPS 的使用这种方式也会有风险。Cookie 的[SameSite 属性](http://www.ruanyifeng.com/blog/2019/09/cookie-samesite.html)用来限制第三方 Cookie，从而减少安全风险
